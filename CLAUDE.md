# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

Leveret is a CLI-based LLM agent for security alert analysis. It receives security alerts in JSON format (e.g., from Amazon GuardDuty), analyzes them using Claude AI and Gemini, and provides interactive analysis capabilities with external tool integration.

**Key Features:**
- Accept and parse security alerts from various sources
- Generate summaries and extract IOCs (Indicators of Compromise) using Claude AI
- Create embeddings with Gemini API for similarity search
- Interactive chat-based analysis with Tool Call loop
- Policy-based filtering using OPA/Rego
- Store alerts and conversation history in Google Cloud (Firestore + Cloud Storage)

## Restriction & Rules

### Export Policy

**IMPORTANT**: Keep symbols (types, functions, variables) private (lowercase) by default throughout the entire project. Only export (capitalize) when absolutely necessary for external package usage.

**Guidelines:**
- Within a package (e.g., `pkg/cli/`), prefer private types and functions
- Only export symbols that are genuinely needed by other packages
- Config structs, helper functions, and internal utilities should be private
- Review each export: "Does another package really need this?"

**Examples:**
- ✅ `type config struct` in `pkg/cli/config.go` (only used within pkg/cli)
- ✅ `func globalFlags(cfg *config)` in `pkg/cli/config.go` (only used within pkg/cli)
- ❌ `type Config struct` when only used internally
- ❌ `func GlobalFlags()` when only called within the same package

### 3rd party packages
- **CLI Framework**: `github.com/urfave/cli/v3` - ALL CLI and environment variable handling
- **Logging**: `slog` with `github.com/m-mizutani/clog` for console output
- **Error handling**: `github.com/m-mizutani/goerr/v2`
- **Testing framework**: `github.com/m-mizutani/gt`

## Architecture

The project follows a layered architecture with clear separation of concerns:

```
cmd/leveret/main.go          # Entry point
pkg/
├── cli/                     # CLI layer: command definitions, argument parsing, DI setup
├── usecase/                 # UseCase layer: business logic orchestration
├── repository/              # Repository layer: data persistence (Firestore)
├── adapter/                 # Adapter layer: external service integration
│   ├── claude.go           # Claude API client
│   ├── gemini.go           # Gemini API client (embeddings)
│   └── storage.go          # Cloud Storage client (conversation history)
└── model/                   # Model layer: shared data structures
```

**Dependency Flow:** CLI → UseCase → Repository/Adapter (unidirectional, top-down)

### Layer Responsibilities

- **CLI Layer ([pkg/cli/](pkg/cli/))**: Parses command-line arguments, reads environment variables and config files, initializes repositories and adapters, performs dependency injection into use cases. ALL environment variable access must happen in this layer only.
- **UseCase Layer ([pkg/usecase/](pkg/usecase/))**: Implements core business logic, coordinates repositories and adapters, handles the Tool Call loop with Claude. Receives all dependencies via constructor injection.
- **Repository Layer ([pkg/repository/](pkg/repository/))**: Abstracts data persistence to Firestore, provides interface for alert CRUD operations and vector search.
- **Adapter Layer ([pkg/adapter/](pkg/adapter/))**: Wraps external service APIs (Claude, Gemini, Cloud Storage), hides implementation details from upper layers.
- **Model Layer ([pkg/model/](pkg/model/))**: Defines shared data structures (Alert, Attribute, etc.).

## Core Data Models

### Alert Structure

```go
type Alert struct {
    ID          AlertID
    Title       string        // Generated by LLM
    Description string        // Generated by LLM
    Data        any           // Original JSON data
    Attributes  []*Attribute  // Extracted attributes (via policy or LLM)

    CreatedAt  time.Time
    ResolvedAt *time.Time
    Conclusion string
    Note       string
    MergedTo   AlertID
}

type Attribute struct {
    Key   string
    Value string
    Type  AttributeType  // string, number, ip_address, etc.
}
```

### Alert Lifecycle

```
new → Policy Check → LLM Summary → Unanalyzed
  ↓
  → chat (interactive analysis via Tool Call loop)
  ↓
  → resolve (mark as resolved)
  → merge (consolidate with another alert)
```

## LLM Integration Strategy

**Use LLM for:**
- Alert summarization and title generation
- IOC (Indicators of Compromise) extraction
- Interactive analysis and natural language queries
- Log query generation from natural language
- Dynamic tool selection based on context

**Do NOT use LLM for:**
- Deterministic filtering (use OPA/Rego policies instead)
- Regular expression-based pattern matching
- Simple threshold checks
- Bulk data processing (cost/rate limit concerns)
- Final impact/priority decisions (human judgment required)

## Commands

### `new` - Register new alert

```bash
leveret new -i alert.json
```

1. Parse JSON alert data
2. Run policy evaluation (accept/reject)
3. Generate summary and extract IOCs via Claude API
4. Generate embedding vector via Gemini API
5. Save to Firestore with generated alert ID

### `chat` - Interactive analysis

```bash
leveret chat <alert-id>
```

1. Fetch alert from Firestore
2. Load conversation history from Cloud Storage
3. Start Tool Call loop with Claude API
4. Execute external tools as requested by Claude
5. Save updated conversation history

### `list` - List alerts

```bash
leveret list       # Exclude merged alerts
leveret list -a    # Include merged alerts
```

### `show` - Show alert details

```bash
leveret show <alert-id>
```

Displays detailed information of a specific alert including title, description, attributes, timestamps, and metadata.

### `search` - Search for similar alerts

```bash
leveret search -q "suspicious login from unknown IP"
leveret search --query "AWS S3 bucket access denied" --limit 10
```

1. Generate embedding vector from query text via Gemini API
2. Perform vector search in Firestore
3. Return similar alerts ordered by similarity

### `resolve` - Mark alert as resolved

```bash
leveret resolve <alert-id> -c "False positive"
```

### `merge`/`unmerge` - Consolidate similar alerts

```bash
leveret merge <source-id> <target-id>
leveret unmerge <alert-id>
```

## Development Commands

### Build and Run

```bash
# Build binary
go build -o leveret ./cmd/leveret

# Run directly without build
go run ./cmd/leveret --help
go run ./cmd/leveret new -i testdata/alert.json

# Run with environment variables
ANTHROPIC_API_KEY=sk-ant-... GOOGLE_CLOUD_PROJECT=your-project go run ./cmd/leveret new -i alert.json
```

### Testing

```bash
# Run all tests
go test ./...

# Run tests for specific package
go test ./pkg/usecase

# Run specific test
go test -run TestCreateAlert ./pkg/usecase

# Run with verbose output
go test -v ./...

# Run with coverage
go test -cover ./...
```

### Code Quality

```bash
# Format code
go fmt ./...

# Vet code
go vet ./...

# Run linter (if configured)
golangci-lint run
```

## External Dependencies

- **Claude API (Anthropic)**: Main LLM for analysis and tool orchestration (Claude 3.5 Sonnet)
- **Gemini API (Google Vertex AI)**: Embedding generation (`text-embedding-004`)
- **Firestore**: Alert storage and vector search
- **Cloud Storage**: Conversation history persistence
- **OPA/Rego**: Policy-based alert filtering (implementation in progress)

## Environment Setup

Required environment variables:
- `ANTHROPIC_API_KEY`: Claude API key
- `GOOGLE_CLOUD_PROJECT`: GCP project ID
- ADC (Application Default Credentials) for GCP services: `gcloud auth application-default login`

## Tool Call Loop Pattern

The chat command uses Claude's Tool Use (Tool Call) pattern:

1. Send prompt + tool definitions to Claude
2. Receive ToolCall instruction from Claude
3. Execute the requested tool
4. Send ToolResult back to Claude
5. Repeat until Claude returns final answer (no more ToolCall)

This enables Claude to dynamically call external APIs like threat intelligence services, log databases, etc.
